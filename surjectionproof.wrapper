#ifndef SECP256K1_CONTEXT_ALL
#define SECP256K1_CONTEXT_ALL SECP256K1_CONTEXT_NONE | SECP256K1_CONTEXT_SIGN | SECP256K1_CONTEXT_VERIFY
#endif

int surjectionproof_parse(size_t *n_inputs, unsigned char *used_inputs, unsigned char *data, const unsigned char *input, size_t inputlen) {
  secp256k1_context *ctx = secp256k1_context_create(SECP256K1_CONTEXT_ALL);
  secp256k1_surjectionproof proof;
  memcpy(&(proof.n_inputs), n_inputs, sizeof(proof.n_inputs));
  memcpy(proof.used_inputs, used_inputs, 32);
  memcpy(proof.data, data, 8224);
  int ret = secp256k1_surjectionproof_parse(ctx, &proof, input, inputlen);
  secp256k1_context_destroy(ctx);
  return ret;
}

int surjectionproof_serialize(unsigned char *output, size_t *outputlen, const size_t *n_inputs, const unsigned char *used_inputs, const unsigned char *data) {
  secp256k1_context *ctx = secp256k1_context_create(SECP256K1_CONTEXT_NONE);
  secp256k1_surjectionproof proof;
  memcpy(&(proof.n_inputs), n_inputs, sizeof(proof.n_inputs));
  memcpy(proof.used_inputs, used_inputs, 32);
  memcpy(proof.data, data, 8224);
  int ret = secp256k1_surjectionproof_serialize(ctx, output, outputlen, &proof);
  secp256k1_context_destroy(ctx);
  return ret;
}

int surjectionproof_initialize(size_t *n_inputs, unsigned char *used_inputs, unsigned char *data, size_t *input_index, const unsigned char * const *input_tags_data, const size_t n_input_tags, const size_t n_input_tags_to_use, const unsigned char *output_tag_data, const size_t n_max_iterations, const unsigned char *random_seed32) {
  secp256k1_context *ctx = secp256k1_context_create(SECP256K1_CONTEXT_ALL);
  secp256k1_surjectionproof proof;
  memcpy(&(proof.n_inputs), n_inputs, sizeof(proof.n_inputs));
  memcpy(proof.used_inputs, used_inputs, 32);
  memcpy(proof.data, data, 8224);
  secp256k1_fixed_asset_tag input_tags[n_input_tags];
  for (int i = 0; i < (int)n_input_tags; ++i) {
    memcpy(input_tags[i].data, input_tags_data[i], 32);
  }
  secp256k1_fixed_asset_tag output_tag;
  memcpy(output_tag.data, output_tag_data, 32);
  int ret = secp256k1_surjectionproof_initialize(ctx, &proof, input_index, input_tags, n_input_tags, n_input_tags_to_use, &output_tag, n_max_iterations, random_seed32);
  if (ret == 1) {
    memcpy(n_inputs, &(proof.n_inputs), sizeof(proof.n_inputs));
    memcpy(used_inputs, proof.used_inputs, 32);
    memcpy(data, proof.data, 8224);
  }
  secp256k1_context_destroy(ctx);
  return ret;
}

int surjectionproof_generate(size_t *n_inputs, unsigned char *used_inputs, unsigned char *data, const unsigned char * const *ephemeral_input_tags_data, const size_t n_ephemeral_input_tags, const unsigned char *ephemeral_output_tag_data, size_t input_index, const unsigned char *input_blinding_key, const unsigned char *output_blinding_key) {
  secp256k1_context *ctx = secp256k1_context_create(SECP256K1_CONTEXT_ALL);
  secp256k1_surjectionproof proof;
  memcpy(&(proof.n_inputs), n_inputs, sizeof(proof.n_inputs));
  memcpy(proof.used_inputs, used_inputs, 32);
  memcpy(proof.data, data, 8224);
  secp256k1_generator ephimeral_input_tags[n_ephemeral_input_tags];
  for (int i = 0; i < (int)n_ephemeral_input_tags; ++i) {
    memcpy(ephimeral_input_tags[i].data, ephemeral_input_tags_data[i], 64);
  }
  secp256k1_generator ephimeral_output_tag;
  memcpy(ephimeral_output_tag.data, ephemeral_output_tag_data, 64);
  int ret = secp256k1_surjectionproof_generate(ctx, &proof, ephimeral_input_tags, n_ephemeral_input_tags, &ephimeral_output_tag, input_index, input_blinding_key, output_blinding_key);
  if (ret == 1) {
    memcpy(n_inputs, &(proof.n_inputs), sizeof(proof.n_inputs));
    memcpy(used_inputs, proof.used_inputs, 32);
    memcpy(data, proof.data, 8224);
  }
  secp256k1_context_destroy(ctx);
  return ret;
}

int surjectionproof_verify(const size_t *n_inputs, const unsigned char *used_inputs, const unsigned char *data, const unsigned char * const *ephemeral_input_tags_data, const size_t n_ephemeral_input_tags, const unsigned char *ephemeral_output_tag_data) {
  secp256k1_context *ctx = secp256k1_context_create(SECP256K1_CONTEXT_VERIFY);
  secp256k1_surjectionproof proof;
  memcpy(&(proof.n_inputs), n_inputs, sizeof(proof.n_inputs));
  memcpy(proof.used_inputs, used_inputs, 32);
  memcpy(proof.data, data, 8224);
  secp256k1_generator ephimeral_input_tags[n_ephemeral_input_tags];
  for (int i = 0; i < (int)n_ephemeral_input_tags; ++i) {
    memcpy(ephimeral_input_tags[i].data, ephemeral_input_tags_data[i], 64);
  }
  secp256k1_generator ephimeral_output_tag;
  memcpy(ephimeral_output_tag.data, ephemeral_output_tag_data, 64);
  int ret = secp256k1_surjectionproof_verify(ctx, &proof, ephimeral_input_tags, n_ephemeral_input_tags, &ephimeral_output_tag);
  secp256k1_context_destroy(ctx);
  return ret;
}
